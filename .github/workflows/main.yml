name: Calculate Stock Returns

on:
  workflow_dispatch:
    inputs:
      mode:
        description: '計算模式'
        required: true
        type: choice
        options:
          - 'single'
          - 'all'
          - 'fill_missing'
        default: 'all'
      symbol:
        description: '股票代碼（單一模式使用，例如：2330）'
        required: false
        default: ''
      start_date:
        description: '開始日期 (YYYY-MM-DD，可選)'
        required: false
        default: ''
      end_date:
        description: '結束日期 (YYYY-MM-DD，可選)'
        required: false
        default: ''
      limit:
        description: '限制處理股票數量（all 模式使用）'
        required: false
        default: '0'
  schedule:
    # 每天 14:30 自動執行
    - cron: '30 6 * * *'  # UTC 06:30 = 台北時間 14:30

env:
  TZ: Asia/Taipei

jobs:
  calculate-returns:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install psycopg2-binary pandas numpy
    
    - name: Calculate returns
      env:
        NEON_DATABASE_URL: ${{ secrets.NEON_DATABASE_URL }}
        MODE: ${{ github.event.inputs.mode || 'fill_missing' }}
        SYMBOL: ${{ github.event.inputs.symbol }}
        START_DATE: ${{ github.event.inputs.start_date }}
        END_DATE: ${{ github.event.inputs.end_date }}
        LIMIT: ${{ github.event.inputs.limit || '0' }}
      run: |
        python3 << 'PYTHON_SCRIPT'
        import os
        import sys
        import psycopg2
        from psycopg2.extras import RealDictCursor, execute_values
        from datetime import datetime, date
        import pandas as pd
        import numpy as np
        
        print("=" * 80)
        print("📊 計算股票報酬率")
        print("=" * 80)
        print(f"⏰ 執行時間：{datetime.now()}")
        
        # 讀取參數
        MODE = os.environ.get('MODE', 'fill_missing')
        SYMBOL = os.environ.get('SYMBOL', '').strip()
        START_DATE = os.environ.get('START_DATE', '').strip() or None
        END_DATE = os.environ.get('END_DATE', '').strip() or None
        LIMIT = int(os.environ.get('LIMIT', '0'))
        
        print(f"📋 模式：{MODE}")
        if SYMBOL:
            print(f"📈 股票：{SYMBOL}")
        if START_DATE:
            print(f"📅 開始日期：{START_DATE}")
        if END_DATE:
            print(f"📅 結束日期：{END_DATE}")
        if LIMIT > 0:
            print(f"🔢 限制數量：{LIMIT}")
        print()
        
        # 連接資料庫
        NEON_DB_URL = os.environ.get('NEON_DATABASE_URL')
        if not NEON_DB_URL:
            print("❌ 錯誤：未設定 NEON_DATABASE_URL")
            sys.exit(1)
        
        try:
            conn = psycopg2.connect(NEON_DB_URL, cursor_factory=RealDictCursor)
            cur = conn.cursor()
            print("✅ 已連接到 Neon 資料庫\n")
        except Exception as e:
            print(f"❌ 資料庫連線失敗：{e}")
            sys.exit(1)
        
        # 確保 stock_returns 表存在
        try:
            cur.execute("""
                CREATE TABLE IF NOT EXISTS stock_returns (
                    id SERIAL PRIMARY KEY,
                    symbol VARCHAR(20) NOT NULL,
                    date DATE NOT NULL,
                    daily_return DECIMAL(10,6),
                    weekly_return DECIMAL(10,6),
                    monthly_return DECIMAL(10,6),
                    quarterly_return DECIMAL(10,6),
                    yearly_return DECIMAL(10,6),
                    cumulative_return DECIMAL(10,6),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(symbol, date)
                );
            """)
            conn.commit()
            print("✅ stock_returns 表已就緒\n")
        except Exception as e:
            print(f"⚠️  建立表失敗：{e}\n")
            conn.rollback()
        
        # 計算報酬率的函數
        def compute_returns_from_close(df):
            """計算各種報酬率"""
            if df.empty:
                return pd.DataFrame()
            
            out = pd.DataFrame(index=df.index)
            
            # 日報酬率
            out["daily_return"] = df["close"].pct_change()
            
            # 週報酬率（5 個交易日）
            out["weekly_return"] = df["close"].pct_change(periods=5)
            
            # 月報酬率（21 個交易日）
            out["monthly_return"] = df["close"].pct_change(periods=21)
            
            # 季報酬率（63 個交易日）
            out["quarterly_return"] = df["close"].pct_change(periods=63)
            
            # 年報酬率（252 個交易日）
            out["yearly_return"] = df["close"].pct_change(periods=252)
            
            # 累積報酬率
            first_price = df["close"].iloc[0]
            out["cumulative_return"] = df["close"] / first_price - 1.0
            
            # 四捨五入到 6 位小數
            out = out.round(6)
            return out
        
        def safe_float(x):
            """安全轉換為 float"""
            try:
                if x is None or (isinstance(x, float) and (np.isnan(x) or np.isinf(x))):
                    return None
                return float(x)
            except Exception:
                return None
        
        def process_symbol(symbol):
            """處理單一股票"""
            try:
                # 1. 獲取股價資料
                params = [symbol]
                sql = "SELECT date, close_price FROM stock_prices WHERE symbol = %s"
                if START_DATE:
                    sql += " AND date >= %s"
                    params.append(START_DATE)
                if END_DATE:
                    sql += " AND date <= %s"
                    params.append(END_DATE)
                sql += " ORDER BY date ASC"
                
                cur.execute(sql, params)
                rows = cur.fetchall()
                
                if not rows:
                    return 0
                
                # 2. 轉換為 DataFrame
                df = pd.DataFrame(rows)
                df['date'] = pd.to_datetime(df['date'])
                df = df.sort_values('date').set_index('date')
                df['close'] = pd.to_numeric(df['close_price'], errors='coerce').astype(float)
                df = df[~df['close'].isna()]
                
                if df.empty:
                    return 0
                
                # 3. 如果是 fill_missing 模式，檢查已存在的日期
                if MODE == 'fill_missing':
                    params_check = [symbol]
                    sql_check = "SELECT date FROM stock_returns WHERE symbol = %s"
                    if START_DATE:
                        sql_check += " AND date >= %s"
                        params_check.append(START_DATE)
                    if END_DATE:
                        sql_check += " AND date <= %s"
                        params_check.append(END_DATE)
                    
                    cur.execute(sql_check, params_check)
                    existing_dates = {row['date'] for row in cur.fetchall()}
                    
                    # 修正：使用 pd.Series 來處理 isin 操作
                    if existing_dates:
                        date_series = pd.Series(df.index.date)
                        mask = ~date_series.isin(existing_dates)
                        df = df[mask]
                    
                    if df.empty:
                        return 0
                
                # 4. 計算報酬率
                ret_df = compute_returns_from_close(df)
                
                # 5. 準備插入資料
                records = []
                for dt, row in ret_df.iterrows():
                    rec = {
                        "symbol": symbol,
                        "date": dt.date(),
                        "daily_return": safe_float(row.get("daily_return")),
                        "weekly_return": safe_float(row.get("weekly_return")),
                        "monthly_return": safe_float(row.get("monthly_return")),
                        "quarterly_return": safe_float(row.get("quarterly_return")),
                        "yearly_return": safe_float(row.get("yearly_return")),
                        "cumulative_return": safe_float(row.get("cumulative_return")),
                    }
                    records.append(rec)
                
                if not records:
                    return 0
                
                # 6. 批次插入
                values = [
                    [
                        r["symbol"], r["date"], r["daily_return"],
                        r["weekly_return"], r["monthly_return"],
                        r["quarterly_return"], r["yearly_return"],
                        r["cumulative_return"]
                    ]
                    for r in records
                ]
                
                execute_values(
                    cur,
                    """
                    INSERT INTO stock_returns 
                    (symbol, date, daily_return, weekly_return, monthly_return,
                     quarterly_return, yearly_return, cumulative_return)
                    VALUES %s
                    ON CONFLICT (symbol, date) DO UPDATE SET
                        daily_return = EXCLUDED.daily_return,
                        weekly_return = EXCLUDED.weekly_return,
                        monthly_return = EXCLUDED.monthly_return,
                        quarterly_return = EXCLUDED.quarterly_return,
                        yearly_return = EXCLUDED.yearly_return,
                        cumulative_return = EXCLUDED.cumulative_return
                    """,
                    values
                )
                
                conn.commit()
                return len(records)
                
            except Exception as e:
                print(f"  ⚠️  {symbol} 處理失敗: {e}")
                conn.rollback()
                return 0
        
        try:
            # 根據模式執行
            if MODE == 'single':
                if not SYMBOL:
                    print("❌ 單一模式需要指定股票代碼")
                    sys.exit(1)
                
                print(f"📊 計算 {SYMBOL} 的報酬率...")
                count = process_symbol(SYMBOL)
                print(f"✅ 完成：寫入 {count} 筆報酬率\n")
                
            else:  # all 或 fill_missing
                # 獲取股票列表
                sql = "SELECT DISTINCT symbol FROM stock_prices ORDER BY symbol"
                if LIMIT > 0:
                    sql += f" LIMIT {LIMIT}"
                
                cur.execute(sql)
                symbols = [row['symbol'] for row in cur.fetchall()]
                
                print(f"📊 準備計算 {len(symbols)} 檔股票的報酬率...\n")
                
                total_written = 0
                success_count = 0
                
                for i, symbol in enumerate(symbols, 1):
                    count = process_symbol(symbol)
                    if count > 0:
                        success_count += 1
                        total_written += count
                    
                    # 每 50 檔顯示進度
                    if i % 50 == 0:
                        print(f"  進度: {i}/{len(symbols)}, 成功: {success_count} 檔, 寫入: {total_written} 筆")
                
                print(f"\n✅ 完成：{success_count}/{len(symbols)} 檔")
                print(f"📦 總計寫入：{total_written} 筆報酬率\n")
            
            print("=" * 80)
            print("🎉 報酬率計算完成！")
            print("=" * 80)
            
        except Exception as e:
            print(f"❌ 執行過程發生錯誤：{e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
            
        finally:
            if cur:
                cur.close()
            if conn:
                conn.close()
        PYTHON_SCRIPT
