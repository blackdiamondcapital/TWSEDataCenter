name: Calculate Stock Returns

on:
  workflow_dispatch:
    inputs:
      mode:
        description: 'è¨ˆç®—æ¨¡å¼'
        required: true
        type: choice
        options:
          - 'single'
          - 'all'
          - 'fill_missing'
        default: 'all'
      symbol:
        description: 'è‚¡ç¥¨ä»£ç¢¼ï¼ˆå–®ä¸€æ¨¡å¼ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š2330ï¼‰'
        required: false
        default: ''
      start_date:
        description: 'é–‹å§‹æ—¥æœŸ (YYYY-MM-DDï¼Œå¯é¸)'
        required: false
        default: ''
      end_date:
        description: 'çµæŸæ—¥æœŸ (YYYY-MM-DDï¼Œå¯é¸)'
        required: false
        default: ''
      limit:
        description: 'é™åˆ¶è™•ç†è‚¡ç¥¨æ•¸é‡ï¼ˆall æ¨¡å¼ä½¿ç”¨ï¼‰'
        required: false
        default: '0'
  schedule:
    # æ¯å¤© 14:30 è‡ªå‹•åŸ·è¡Œ
    - cron: '30 6 * * *'  # UTC 06:30 = å°åŒ—æ™‚é–“ 14:30

env:
  TZ: Asia/Taipei

jobs:
  calculate-returns:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install psycopg2-binary pandas numpy
    
    - name: Calculate returns
      env:
        NEON_DATABASE_URL: ${{ secrets.NEON_DATABASE_URL }}
        MODE: ${{ github.event.inputs.mode || 'fill_missing' }}
        SYMBOL: ${{ github.event.inputs.symbol }}
        START_DATE: ${{ github.event.inputs.start_date }}
        END_DATE: ${{ github.event.inputs.end_date }}
        LIMIT: ${{ github.event.inputs.limit || '0' }}
      run: |
        python3 << 'PYTHON_SCRIPT'
        import os
        import sys
        import psycopg2
        from psycopg2.extras import RealDictCursor, execute_values
        from datetime import datetime, date
        import pandas as pd
        import numpy as np
        
        print("=" * 80)
        print("ğŸ“Š è¨ˆç®—è‚¡ç¥¨å ±é…¬ç‡")
        print("=" * 80)
        print(f"â° åŸ·è¡Œæ™‚é–“ï¼š{datetime.now()}")
        
        # è®€å–åƒæ•¸
        MODE = os.environ.get('MODE', 'fill_missing')
        SYMBOL = os.environ.get('SYMBOL', '').strip()
        START_DATE = os.environ.get('START_DATE', '').strip() or None
        END_DATE = os.environ.get('END_DATE', '').strip() or None
        LIMIT = int(os.environ.get('LIMIT', '0'))
        
        print(f"ğŸ“‹ æ¨¡å¼ï¼š{MODE}")
        if SYMBOL:
            print(f"ğŸ“ˆ è‚¡ç¥¨ï¼š{SYMBOL}")
        if START_DATE:
            print(f"ğŸ“… é–‹å§‹æ—¥æœŸï¼š{START_DATE}")
        if END_DATE:
            print(f"ğŸ“… çµæŸæ—¥æœŸï¼š{END_DATE}")
        if LIMIT > 0:
            print(f"ğŸ”¢ é™åˆ¶æ•¸é‡ï¼š{LIMIT}")
        print()
        
        # é€£æ¥è³‡æ–™åº«
        NEON_DB_URL = os.environ.get('NEON_DATABASE_URL')
        if not NEON_DB_URL:
            print("âŒ éŒ¯èª¤ï¼šæœªè¨­å®š NEON_DATABASE_URL")
            sys.exit(1)
        
        try:
            conn = psycopg2.connect(NEON_DB_URL, cursor_factory=RealDictCursor)
            cur = conn.cursor()
            print("âœ… å·²é€£æ¥åˆ° Neon è³‡æ–™åº«\n")
        except Exception as e:
            print(f"âŒ è³‡æ–™åº«é€£ç·šå¤±æ•—ï¼š{e}")
            sys.exit(1)
        
        # ç¢ºä¿ stock_returns è¡¨å­˜åœ¨
        try:
            cur.execute("""
                CREATE TABLE IF NOT EXISTS stock_returns (
                    id SERIAL PRIMARY KEY,
                    symbol VARCHAR(20) NOT NULL,
                    date DATE NOT NULL,
                    daily_return DECIMAL(10,6),
                    weekly_return DECIMAL(10,6),
                    monthly_return DECIMAL(10,6),
                    quarterly_return DECIMAL(10,6),
                    yearly_return DECIMAL(10,6),
                    cumulative_return DECIMAL(10,6),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(symbol, date)
                );
            """)
            conn.commit()
            print("âœ… stock_returns è¡¨å·²å°±ç·’\n")
        except Exception as e:
            print(f"âš ï¸  å»ºç«‹è¡¨å¤±æ•—ï¼š{e}\n")
            conn.rollback()
        
        # è¨ˆç®—å ±é…¬ç‡çš„å‡½æ•¸
        def compute_returns_from_close(df):
            """è¨ˆç®—å„ç¨®å ±é…¬ç‡"""
            if df.empty:
                return pd.DataFrame()
            
            out = pd.DataFrame(index=df.index)
            
            # æ—¥å ±é…¬ç‡
            out["daily_return"] = df["close"].pct_change()
            
            # é€±å ±é…¬ç‡ï¼ˆ5 å€‹äº¤æ˜“æ—¥ï¼‰
            out["weekly_return"] = df["close"].pct_change(periods=5)
            
            # æœˆå ±é…¬ç‡ï¼ˆ21 å€‹äº¤æ˜“æ—¥ï¼‰
            out["monthly_return"] = df["close"].pct_change(periods=21)
            
            # å­£å ±é…¬ç‡ï¼ˆ63 å€‹äº¤æ˜“æ—¥ï¼‰
            out["quarterly_return"] = df["close"].pct_change(periods=63)
            
            # å¹´å ±é…¬ç‡ï¼ˆ252 å€‹äº¤æ˜“æ—¥ï¼‰
            out["yearly_return"] = df["close"].pct_change(periods=252)
            
            # ç´¯ç©å ±é…¬ç‡
            first_price = df["close"].iloc[0]
            out["cumulative_return"] = df["close"] / first_price - 1.0
            
            # å››æ¨äº”å…¥åˆ° 6 ä½å°æ•¸
            out = out.round(6)
            return out
        
        def safe_float(x):
            """å®‰å…¨è½‰æ›ç‚º float"""
            try:
                if x is None or (isinstance(x, float) and (np.isnan(x) or np.isinf(x))):
                    return None
                return float(x)
            except Exception:
                return None
        
        def process_symbol(symbol):
            """è™•ç†å–®ä¸€è‚¡ç¥¨"""
            try:
                # 1. ç²å–è‚¡åƒ¹è³‡æ–™
                params = [symbol]
                sql = "SELECT date, close_price FROM stock_prices WHERE symbol = %s"
                if START_DATE:
                    sql += " AND date >= %s"
                    params.append(START_DATE)
                if END_DATE:
                    sql += " AND date <= %s"
                    params.append(END_DATE)
                sql += " ORDER BY date ASC"
                
                cur.execute(sql, params)
                rows = cur.fetchall()
                
                if not rows:
                    return 0
                
                # 2. è½‰æ›ç‚º DataFrame
                df = pd.DataFrame(rows)
                df['date'] = pd.to_datetime(df['date'])
                df = df.sort_values('date').set_index('date')
                df['close'] = pd.to_numeric(df['close_price'], errors='coerce').astype(float)
                df = df[~df['close'].isna()]
                
                if df.empty:
                    return 0
                
                # 3. å¦‚æœæ˜¯ fill_missing æ¨¡å¼ï¼Œæª¢æŸ¥å·²å­˜åœ¨çš„æ—¥æœŸ
                if MODE == 'fill_missing':
                    params_check = [symbol]
                    sql_check = "SELECT date FROM stock_returns WHERE symbol = %s"
                    if START_DATE:
                        sql_check += " AND date >= %s"
                        params_check.append(START_DATE)
                    if END_DATE:
                        sql_check += " AND date <= %s"
                        params_check.append(END_DATE)
                    
                    cur.execute(sql_check, params_check)
                    existing_dates = {row['date'] for row in cur.fetchall()}
                    
                    # ä¿®æ­£ï¼šä½¿ç”¨ pd.Series ä¾†è™•ç† isin æ“ä½œ
                    if existing_dates:
                        date_series = pd.Series(df.index.date)
                        mask = ~date_series.isin(existing_dates)
                        df = df[mask]
                    
                    if df.empty:
                        return 0
                
                # 4. è¨ˆç®—å ±é…¬ç‡
                ret_df = compute_returns_from_close(df)
                
                # 5. æº–å‚™æ’å…¥è³‡æ–™
                records = []
                for dt, row in ret_df.iterrows():
                    rec = {
                        "symbol": symbol,
                        "date": dt.date(),
                        "daily_return": safe_float(row.get("daily_return")),
                        "weekly_return": safe_float(row.get("weekly_return")),
                        "monthly_return": safe_float(row.get("monthly_return")),
                        "quarterly_return": safe_float(row.get("quarterly_return")),
                        "yearly_return": safe_float(row.get("yearly_return")),
                        "cumulative_return": safe_float(row.get("cumulative_return")),
                    }
                    records.append(rec)
                
                if not records:
                    return 0
                
                # 6. æ‰¹æ¬¡æ’å…¥
                values = [
                    [
                        r["symbol"], r["date"], r["daily_return"],
                        r["weekly_return"], r["monthly_return"],
                        r["quarterly_return"], r["yearly_return"],
                        r["cumulative_return"]
                    ]
                    for r in records
                ]
                
                execute_values(
                    cur,
                    """
                    INSERT INTO stock_returns 
                    (symbol, date, daily_return, weekly_return, monthly_return,
                     quarterly_return, yearly_return, cumulative_return)
                    VALUES %s
                    ON CONFLICT (symbol, date) DO UPDATE SET
                        daily_return = EXCLUDED.daily_return,
                        weekly_return = EXCLUDED.weekly_return,
                        monthly_return = EXCLUDED.monthly_return,
                        quarterly_return = EXCLUDED.quarterly_return,
                        yearly_return = EXCLUDED.yearly_return,
                        cumulative_return = EXCLUDED.cumulative_return
                    """,
                    values
                )
                
                conn.commit()
                return len(records)
                
            except Exception as e:
                print(f"  âš ï¸  {symbol} è™•ç†å¤±æ•—: {e}")
                conn.rollback()
                return 0
        
        try:
            # æ ¹æ“šæ¨¡å¼åŸ·è¡Œ
            if MODE == 'single':
                if not SYMBOL:
                    print("âŒ å–®ä¸€æ¨¡å¼éœ€è¦æŒ‡å®šè‚¡ç¥¨ä»£ç¢¼")
                    sys.exit(1)
                
                print(f"ğŸ“Š è¨ˆç®— {SYMBOL} çš„å ±é…¬ç‡...")
                count = process_symbol(SYMBOL)
                print(f"âœ… å®Œæˆï¼šå¯«å…¥ {count} ç­†å ±é…¬ç‡\n")
                
            else:  # all æˆ– fill_missing
                # ç²å–è‚¡ç¥¨åˆ—è¡¨
                sql = "SELECT DISTINCT symbol FROM stock_prices ORDER BY symbol"
                if LIMIT > 0:
                    sql += f" LIMIT {LIMIT}"
                
                cur.execute(sql)
                symbols = [row['symbol'] for row in cur.fetchall()]
                
                print(f"ğŸ“Š æº–å‚™è¨ˆç®— {len(symbols)} æª”è‚¡ç¥¨çš„å ±é…¬ç‡...\n")
                
                total_written = 0
                success_count = 0
                
                for i, symbol in enumerate(symbols, 1):
                    count = process_symbol(symbol)
                    if count > 0:
                        success_count += 1
                        total_written += count
                    
                    # æ¯ 50 æª”é¡¯ç¤ºé€²åº¦
                    if i % 50 == 0:
                        print(f"  é€²åº¦: {i}/{len(symbols)}, æˆåŠŸ: {success_count} æª”, å¯«å…¥: {total_written} ç­†")
                
                print(f"\nâœ… å®Œæˆï¼š{success_count}/{len(symbols)} æª”")
                print(f"ğŸ“¦ ç¸½è¨ˆå¯«å…¥ï¼š{total_written} ç­†å ±é…¬ç‡\n")
            
            print("=" * 80)
            print("ğŸ‰ å ±é…¬ç‡è¨ˆç®—å®Œæˆï¼")
            print("=" * 80)
            
        except Exception as e:
            print(f"âŒ åŸ·è¡Œéç¨‹ç™¼ç”ŸéŒ¯èª¤ï¼š{e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
            
        finally:
            if cur:
                cur.close()
            if conn:
                conn.close()
        PYTHON_SCRIPT
