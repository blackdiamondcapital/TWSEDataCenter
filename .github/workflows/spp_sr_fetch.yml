name: Daily Stock Data Fetch

on:
  schedule:
    # æ¯å¤©ä¸‹åˆ 1:55 åŸ·è¡Œèˆ‡ä¸‹åˆ2:30ï¼ˆå°åŒ—æ™‚é–“ 13:55 = UTC 06:00ï¼‰
    - cron: '55 5 * * *'
    - cron: '30 6 * * *' 
  workflow_dispatch:

env:
  TZ: Asia/Taipei

jobs:
  fetch-stock-data:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
        cache: 'pip'
        cache-dependency-path: 'requirements.txt'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Fetch stock data and sync to Neon, then compute returns
      env:
        NEON_DATABASE_URL: ${{ secrets.NEON_DATABASE_URL }}
        PYTHONUNBUFFERED: 1
      run: |
        python3 -u << 'PYTHON_SCRIPT'
        import os
        import sys
        import time
        import requests
        import psycopg2
        from psycopg2.extras import execute_values
        from datetime import datetime, date, timedelta
        from bs4 import BeautifulSoup
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import threading

        # å¼·åˆ¶å³æ™‚è¼¸å‡º
        sys.stdout.flush()
        sys.stderr.flush()

        print("=" * 80, flush=True)
        print("ğŸš€ é–‹å§‹åŸ·è¡Œ GitHub Actions è‚¡åƒ¹è³‡æ–™æŠ“å–ä»»å‹™", flush=True)
        print("=" * 80, flush=True)
        print(f"â° åŸ·è¡Œæ™‚é–“ï¼š{datetime.now()}", flush=True)
        print(f"ğŸ“… ç›®æ¨™æ—¥æœŸï¼š{date.today()}", flush=True)
        print(flush=True)

        # é€£æ¥ Neon è³‡æ–™åº«
        NEON_DB_URL = os.environ.get('NEON_DATABASE_URL')

        if not NEON_DB_URL:
            print("âŒ éŒ¯èª¤ï¼šæœªè¨­å®š NEON_DATABASE_URL", flush=True)
            print("è«‹åœ¨ GitHub Settings â†’ Secrets ä¸­è¨­å®š NEON_DATABASE_URL", flush=True)
            sys.exit(1)

        try:
            print("ğŸ”Œ æ­£åœ¨é€£æ¥ Neon è³‡æ–™åº«...", flush=True)
            conn = psycopg2.connect(NEON_DB_URL)
            cur = conn.cursor()
            print("âœ… å·²é€£æ¥åˆ° Neon è³‡æ–™åº«", flush=True)
            print(flush=True)

        except Exception as e:
            print(f"âŒ è³‡æ–™åº«é€£ç·šå¤±æ•—ï¼š{e}", flush=True)
            sys.exit(1)

        # ========================================
        # å‡½æ•¸ï¼šå–å¾—è‚¡ç¥¨æ¸…å–®
        # ========================================
        def get_stock_symbols():
            """å–å¾—ä¸Šå¸‚ä¸Šæ«ƒè‚¡ç¥¨æ¸…å–®"""
            print("ğŸ“‹ å–å¾—è‚¡ç¥¨æ¸…å–®...", flush=True)
            headers = {'User-Agent': 'Mozilla/5.0'}

            # å–å¾—ä¸Šå¸‚è‚¡ç¥¨
            twse_symbols = []
            try:
                print("  â³ æ­£åœ¨æŠ“å–ä¸Šå¸‚è‚¡ç¥¨æ¸…å–®ï¼ˆç´„éœ€ 15-30 ç§’ï¼‰...", flush=True)
                url = 'https://isin.twse.com.tw/isin/C_public.jsp?strMode=2'
                response = requests.get(url, headers=headers, timeout=60)
                response.encoding = 'big5'
                soup = BeautifulSoup(response.text, 'html.parser')

                for row in soup.find_all('tr'):
                    cols = row.find_all('td')
                    if len(cols) >= 5:
                        code_name = cols[0].text.strip()
                        if '\u3000' in code_name:
                            parts = code_name.split('\u3000')
                            if len(parts) == 2 and parts[0].isdigit() and len(parts[0]) == 4:
                                twse_symbols.append(parts[0])
                print(f"âœ… ä¸Šå¸‚è‚¡ç¥¨ï¼š{len(twse_symbols)} æª”", flush=True)
            except Exception as e:
                print(f"âš ï¸  ç„¡æ³•å–å¾—ä¸Šå¸‚æ¸…å–®: {e}", flush=True)

            # å–å¾—ä¸Šæ«ƒè‚¡ç¥¨  
            tpex_symbols = []
            try:
                url = 'https://isin.twse.com.tw/isin/C_public.jsp?strMode=4'
                response = requests.get(url, headers=headers, timeout=30)
                response.encoding = 'big5'
                soup = BeautifulSoup(response.text, 'html.parser')

                for row in soup.find_all('tr'):
                    cols = row.find_all('td')
                    if len(cols) >= 5:
                        code_name = cols[0].text.strip()
                        security_type = cols[1].text.strip() if len(cols) > 1 else ''

                        # åªå–è‚¡ç¥¨ï¼Œæ’é™¤ ETFã€æ¬Šè­‰ã€å‚µåˆ¸ç­‰
                        exclude_keywords = ['ETF', 'DR', 'TDR', 'èªè³¼', 'èªå”®', 'å‚µåˆ¸', 'å—ç›Šè­‰åˆ¸', 'åŸºé‡‘']
                        is_excluded = any(keyword in security_type for keyword in exclude_keywords)

                        if '\u3000' in code_name and not is_excluded:
                            parts = code_name.split('\u3000')
                            if len(parts) == 2 and parts[0].isdigit() and len(parts[0]) == 4:
                                tpex_symbols.append(parts[0])
                print(f"âœ… ä¸Šæ«ƒè‚¡ç¥¨ï¼š{len(tpex_symbols)} æª”", flush=True)
            except Exception as e:
                print(f"âš ï¸  ç„¡æ³•å–å¾—ä¸Šæ«ƒæ¸…å–®: {e}", flush=True)

            return twse_symbols, tpex_symbols

        # ========================================
        # å‡½æ•¸ï¼šæŠ“å–å–®æª”è‚¡ç¥¨è³‡æ–™
        # ========================================
        def fetch_stock_data_single_day(symbol, target_date, is_twse=True):
            """æŠ“å–å–®æª”è‚¡ç¥¨å–®æ—¥è³‡æ–™"""
            year = target_date.year
            month = target_date.month
            day = target_date.day

            headers = {'User-Agent': 'Mozilla/5.0'}

            try:
                if is_twse:
                    # ä¸Šå¸‚ï¼šä½¿ç”¨æœˆè³‡æ–™ API
                    url = 'https://www.twse.com.tw/exchangeReport/STOCK_DAY'
                    params = {
                        'response': 'json',
                        'date': f'{year}{month:02d}01',
                        'stockNo': symbol
                    }

                    response = requests.get(url, params=params, headers=headers, timeout=10)
                    if response.status_code != 200:
                        return None

                    data = response.json()
                    if data.get('stat') == 'OK' and data.get('data'):
                        for row in data['data']:
                            try:
                                date_parts = row[0].split('/')
                                if len(date_parts) == 3:
                                    year_roc = int(date_parts[0]) + 1911
                                    month_val = int(date_parts[1])
                                    day_val = int(date_parts[2])
                                    trade_date = date(year_roc, month_val, day_val)

                                    if trade_date == target_date:
                                        volume = int(row[1].replace(',', '')) if row[1] != '--' else 0
                                        open_price = float(row[3].replace(',', '')) if row[3] != '--' else None
                                        high_price = float(row[4].replace(',', '')) if row[4] != '--' else None
                                        low_price = float(row[5].replace(',', '')) if row[5] != '--' else None
                                        close_price = float(row[6].replace(',', '')) if row[6] != '--' else None

                                        if close_price and 0 < close_price < 30000:
                                            symbol_with_suffix = f"{symbol}.TW"
                                            return (symbol_with_suffix, target_date, open_price, high_price,
                                                    low_price, close_price, volume)
                            except (ValueError, IndexError):
                                continue
                else:
                    # ä¸Šæ«ƒï¼šä½¿ç”¨æ—¥è³‡æ–™ APIï¼ˆæ­£ç¢ºçš„ APIï¼‰
                    roc_date = f'{year-1911}/{month:02d}/{day:02d}'
                    url = 'https://www.tpex.org.tw/web/stock/aftertrading/otc_quotes_no1430/stk_wn1430_result.php'
                    params = {
                        'l': 'zh-tw',
                        'd': roc_date,
                        'se': 'AL'
                    }

                    response = requests.get(url, params=params, headers=headers, timeout=10)
                    if response.status_code != 200:
                        return None

                    data = response.json()

                    # æª¢æŸ¥ tables æ ¼å¼ï¼ˆä¸Šæ«ƒ API è¿”å›æ ¼å¼ï¼‰
                    if data.get('tables') and len(data['tables']) > 0:
                        table_data = data['tables'][0].get('data', [])

                        for row in table_data:
                            try:
                                stock_symbol = row[0].strip()
                                if stock_symbol != symbol:
                                    continue

                                close_price = float(row[2].replace(',', '')) if row[2] not in ['-', '----', ''] else None
                                open_price = float(row[4].replace(',', '')) if row[4] not in ['-', '----', ''] else None
                                high_price = float(row[5].replace(',', '')) if row[5] not in ['-', '----', ''] else None
                                low_price = float(row[6].replace(',', '')) if row[6] not in ['-', '----', ''] else None
                                volume = int(row[7].replace(',', '')) if row[7] not in ['-', '0', ''] else 0

                                if close_price and 0 < close_price < 30000:
                                    symbol_with_suffix = f"{symbol}.TWO"
                                    return (symbol_with_suffix, target_date, open_price, high_price,
                                            low_price, close_price, volume)
                            except (ValueError, IndexError):
                                continue

            except Exception:
                pass

            return None

        def fetch_twii_single_day(target_date):
            """æŠ“å–å°ç£åŠ æ¬ŠæŒ‡æ•¸ (^TWII) å–®æ—¥è³‡æ–™ï¼ˆä½¿ç”¨è­‰äº¤æ‰€ FMTQIK APIï¼‰"""
            print("ğŸ“ˆ å˜—è©¦å¾è­‰äº¤æ‰€ FMTQIK æŠ“å–åŠ æ¬ŠæŒ‡æ•¸ (^TWII)...", flush=True)
            try:
                month_anchor = target_date.replace(day=1)
                url = 'https://www.twse.com.tw/exchangeReport/FMTQIK'
                params = {
                    'response': 'json',
                    'date': month_anchor.strftime('%Y%m%d')
                }

                response = requests.get(url, params=params, timeout=15)
                if response.status_code != 200:
                    print(f"âš ï¸ FMTQIK API å›æ‡‰ç¢¼ {response.status_code}", flush=True)
                    return None

                payload = response.json()
                if payload.get('stat') != 'OK' or not payload.get('data'):
                    print("âš ï¸ FMTQIK API ç„¡æœ‰æ•ˆè³‡æ–™", flush=True)
                    return None

                def parse_roc_date(roc_str: str):
                    try:
                        year_str, month_str, day_str = roc_str.split('/')
                        year_val = int(year_str) + 1911
                        month_val = int(month_str)
                        day_val = int(day_str)
                        return date(year_val, month_val, day_val)
                    except Exception:
                        return None

                def safe_float(val):
                    if val in (None, '', '--', '---'):
                        return None
                    try:
                        return float(val.replace(',', ''))
                    except Exception:
                        return None

                def safe_volume(val):
                    if val in (None, '', '--', '---'):
                        return 0
                    try:
                        return int(val.replace(',', '')) * 1000  # ç”±åƒå…ƒè½‰å…ƒ
                    except Exception:
                        return 0

                for row in payload.get('data', []):
                    row_date = parse_roc_date(row[0]) if len(row) > 0 else None
                    if row_date != target_date:
                        continue

                    close_price = safe_float(row[4] if len(row) > 4 else None)
                    if close_price is None:
                        print("âš ï¸ FMTQIK ç¼ºå°‘æŒ‡æ•¸å€¼ï¼Œç•¥é", flush=True)
                        return None

                    turnover_amount = safe_volume(row[2] if len(row) > 2 else None)

                    return (
                        '^TWII',
                        target_date,
                        close_price,
                        close_price,
                        close_price,
                        close_price,
                        turnover_amount
                    )

                print("âš ï¸ FMTQIK è³‡æ–™ä¸­æ‰¾ä¸åˆ°ç›®æ¨™æ—¥æœŸ", flush=True)
                return None
            except Exception as err:
                print(f"âš ï¸ åŠ æ¬ŠæŒ‡æ•¸æŠ“å–å¤±æ•—: {err}", flush=True)
                return None

        # ========================================
        # ä¸»è¦åŸ·è¡Œæµç¨‹
        # ========================================
        try:
            today = date.today()

            # 1. å–å¾—è‚¡ç¥¨æ¸…å–®
            twse_symbols, tpex_symbols = get_stock_symbols()
            total_symbols = len(twse_symbols) + len(tpex_symbols)

            if total_symbols == 0:
                print("âŒ ç„¡æ³•å–å¾—è‚¡ç¥¨æ¸…å–®", flush=True)
                sys.exit(1)

            print(f"\nğŸ“Š æº–å‚™æŠ“å– {total_symbols} æª”è‚¡ç¥¨è³‡æ–™", flush=True)
            print(f"   ä¸Šå¸‚ï¼š{len(twse_symbols)} æª”", flush=True)
            print(f"   ä¸Šæ«ƒï¼š{len(tpex_symbols)} æª”", flush=True)
            print(flush=True)

            # 2. ä½¿ç”¨ä½µç™¼æŠ“å–åŠ é€Ÿï¼ˆ10 å€‹ä½µç™¼ï¼‰
            all_records = []
            lock = threading.Lock()

            def fetch_and_collect(symbol, is_twse):
                """ä½µç™¼æŠ“å–å–®æª”è‚¡ç¥¨"""
                result = fetch_stock_data_single_day(symbol, today, is_twse)
                if result:
                    with lock:
                        all_records.append(result)
                time.sleep(0.3)
                return result is not None

            print("ğŸ“¥ ä½¿ç”¨ä½µç™¼æŠ“å–ä¸Šå¸‚è‚¡ç¥¨ï¼ˆ10 ä½µç™¼ï¼‰...", flush=True)
            success_count = 0
            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = {executor.submit(fetch_and_collect, symbol, True): symbol
                          for symbol in twse_symbols}

                for i, future in enumerate(as_completed(futures), 1):
                    if future.result():
                        success_count += 1

                    if i % 50 == 0 or i == len(twse_symbols):
                        print(f"  é€²åº¦: {i}/{len(twse_symbols)}, æˆåŠŸ: {success_count}", flush=True)
                        sys.stdout.flush()

            print(f"âœ… ä¸Šå¸‚è‚¡ç¥¨å®Œæˆï¼š{success_count} / {len(twse_symbols)} æª”", flush=True)

            twse_count = success_count
            success_count = 0

            print("\nğŸ“¥ ä½¿ç”¨ä½µç™¼æŠ“å–ä¸Šæ«ƒè‚¡ç¥¨ï¼ˆ10 ä½µç™¼ï¼‰...", flush=True)
            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = {executor.submit(fetch_and_collect, symbol, False): symbol
                          for symbol in tpex_symbols}

                for i, future in enumerate(as_completed(futures), 1):
                    if future.result():
                        success_count += 1

                    if i % 50 == 0 or i == len(tpex_symbols):
                        print(f"  é€²åº¦: {i}/{len(tpex_symbols)}, æˆåŠŸ: {success_count}", flush=True)
                        sys.stdout.flush()

            print(f"âœ… ä¸Šæ«ƒè‚¡ç¥¨å®Œæˆï¼š{success_count} / {len(tpex_symbols)} æª”", flush=True)
            print(f"\nğŸ“¦ ç¸½è¨ˆæŠ“å–ï¼š{len(all_records)} ç­†è³‡æ–™", flush=True)

            # 3. åŠ å…¥å°ç£åŠ æ¬ŠæŒ‡æ•¸
            index_record = fetch_twii_single_day(today)
            if index_record:
                all_records.append(index_record)
                print(f"ğŸ“ˆ å·²åŠ å…¥åŠ æ¬ŠæŒ‡æ•¸è³‡æ–™ï¼Œç¸½ç­†æ•¸ï¼š{len(all_records)}", flush=True)
            else:
                print("âš ï¸ æœ¬æ¬¡æœªå–å¾—åŠ æ¬ŠæŒ‡æ•¸ (^TWII) è³‡æ–™", flush=True)

            # 3. æª¢æŸ¥æ˜¯å¦æœ‰è³‡æ–™
            if not all_records:
                print("âš ï¸  ä»Šæ—¥ç„¡è³‡æ–™å¯åŒæ­¥ï¼ˆå¯èƒ½æ˜¯éäº¤æ˜“æ—¥æˆ–è³‡æ–™å°šæœªå…¬å¸ƒï¼‰", flush=True)
                print("âœ… ä»»å‹™å®Œæˆï¼ˆç„¡è³‡æ–™æ›´æ–°ï¼‰", flush=True)
                sys.exit(0)

            print(flush=True)
            print(f"ğŸ“¦ æº–å‚™åŒæ­¥ {len(all_records)} ç­†è³‡æ–™åˆ° Neon è³‡æ–™åº«...", flush=True)

            # é‡æ–°é€£æ¥è³‡æ–™åº«ï¼ˆé¿å…è¶…æ™‚ï¼‰
            try:
                cur.close()
                conn.close()
                print("ğŸ”„ é‡æ–°é€£æ¥è³‡æ–™åº«...", flush=True)
                conn = psycopg2.connect(NEON_DB_URL)
                cur = conn.cursor()
                print("âœ… è³‡æ–™åº«é‡æ–°é€£æ¥æˆåŠŸ", flush=True)
            except Exception as e:
                print(f"âŒ é‡æ–°é€£æ¥å¤±æ•—ï¼š{e}", flush=True)
                sys.exit(1)

            # ç¢ºä¿ tw_stock_prices è¡¨å­˜åœ¨ï¼ˆé¦–æ¬¡åŸ·è¡Œæ™‚é¿å…å› è¡¨ä¸å­˜åœ¨è€Œå¤±æ•—ï¼‰
            try:
                cur.execute(
                    """
                    CREATE TABLE IF NOT EXISTS tw_stock_prices (
                        id SERIAL PRIMARY KEY,
                        symbol VARCHAR(20) NOT NULL,
                        date DATE NOT NULL,
                        open_price DECIMAL(10,2),
                        high_price DECIMAL(10,2),
                        low_price DECIMAL(10,2),
                        close_price DECIMAL(10,2),
                        volume BIGINT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(symbol, date)
                    );
                    """
                )
                cur.execute(
                    """
                    CREATE UNIQUE INDEX IF NOT EXISTS tw_stock_prices_symbol_date_idx
                    ON tw_stock_prices(symbol, date);
                    """
                )
                conn.commit()
            except Exception as e:
                print(f"âš ï¸ å»ºç«‹ tw_stock_prices è¡¨å¤±æ•—: {e}", flush=True)
                conn.rollback()

            # 4. åˆ†æ‰¹æ’å…¥åˆ° Neon è³‡æ–™åº«ï¼ˆtw_stock_pricesï¼‰
            batch_size = 1000
            total_inserted = 0

            for i in range(0, len(all_records), batch_size):
                batch = all_records[i:i + batch_size]

                try:
                    execute_values(
                        cur,
                        """
                        INSERT INTO tw_stock_prices 
                        (symbol, date, open_price, high_price, low_price, close_price, volume)
                        VALUES %s
                        ON CONFLICT (symbol, date) 
                        DO UPDATE SET
                            open_price = EXCLUDED.open_price,
                            high_price = EXCLUDED.high_price,
                            low_price = EXCLUDED.low_price,
                            close_price = EXCLUDED.close_price,
                            volume = EXCLUDED.volume
                        """,
                        batch
                    )

                    conn.commit()
                    total_inserted += len(batch)
                    print(f"  å·²åŒæ­¥: {total_inserted}/{len(all_records)} ç­†", flush=True)
                    sys.stdout.flush()

                except Exception as e:
                    print(f"  âš ï¸  æ‰¹æ¬¡ {i//batch_size + 1} å¤±æ•—: {e}", flush=True)
                    conn.rollback()

            print(f"âœ… æˆåŠŸåŒæ­¥ {total_inserted} ç­†è³‡æ–™åˆ° tw_stock_prices", flush=True)

            # 5. å»ºç«‹/æ›´æ–° tw_stock_returns ä¸¦è¨ˆç®—ä»Šæ—¥å ±é…¬ç‡ï¼ˆdaily/weekly/monthlyï¼‰
            try:
                print("\nğŸ§® è¨ˆç®—ä¸¦å›å¯«ä»Šæ—¥å ±é…¬ç‡åˆ° tw_stock_returns...", flush=True)

                # å»ºè¡¨ï¼ˆè‹¥ä¸å­˜åœ¨ï¼‰
                cur.execute(
                    """
                    CREATE TABLE IF NOT EXISTS tw_stock_returns (
                        id SERIAL PRIMARY KEY,
                        symbol VARCHAR(20) NOT NULL,
                        date DATE NOT NULL,
                        daily_return DECIMAL(10,6),
                        weekly_return DECIMAL(10,6),
                        monthly_return DECIMAL(10,6),
                        quarterly_return DECIMAL(10,6),
                        yearly_return DECIMAL(10,6),
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(symbol, date)
                    );
                    """
                )
                cur.execute(
                    """
                    CREATE UNIQUE INDEX IF NOT EXISTS tw_stock_returns_symbol_date_idx
                    ON tw_stock_returns(symbol, date);
                    """
                )

                # ä½¿ç”¨è¦–çª—å‡½æ•¸ç”± tw_stock_prices è¨ˆç®—ä»Šæ—¥ rolling å ±é…¬ç‡
                cur.execute(
                    """
                    WITH s AS (
                        SELECT
                            symbol,
                            date,
                            close_price,
                            LAG(close_price, 1)   OVER (PARTITION BY symbol ORDER BY date) AS prev_1,
                            LAG(close_price, 5)   OVER (PARTITION BY symbol ORDER BY date) AS prev_5,
                            LAG(close_price, 21)  OVER (PARTITION BY symbol ORDER BY date) AS prev_21,
                            LAG(close_price, 63)  OVER (PARTITION BY symbol ORDER BY date) AS prev_63,
                            LAG(close_price, 252) OVER (PARTITION BY symbol ORDER BY date) AS prev_252
                        FROM tw_stock_prices
                        WHERE date >= %s - INTERVAL '1000 days' AND date <= %s
                    ), firsts AS (
                        SELECT DISTINCT ON (symbol)
                            symbol,
                            close_price AS first_close
                        FROM tw_stock_prices
                        ORDER BY symbol, date ASC
                    ), t AS (
                        SELECT
                            s.symbol,
                            s.date,
                            CASE WHEN s.close_price IS NULL OR s.prev_1 IS NULL OR s.prev_1 = 0
                                 THEN NULL ELSE ROUND((s.close_price/s.prev_1 - 1)::numeric, 6) END AS daily_return,
                            CASE WHEN s.close_price IS NULL OR s.prev_5 IS NULL OR s.prev_5 = 0
                                 THEN NULL ELSE ROUND((s.close_price/s.prev_5 - 1)::numeric, 6) END AS weekly_return,
                            CASE WHEN s.close_price IS NULL OR s.prev_21 IS NULL OR s.prev_21 = 0
                                 THEN NULL ELSE ROUND((s.close_price/s.prev_21 - 1)::numeric, 6) END AS monthly_return,
                            CASE WHEN s.close_price IS NULL OR s.prev_63 IS NULL OR s.prev_63 = 0
                                 THEN NULL ELSE ROUND((s.close_price/s.prev_63 - 1)::numeric, 6) END AS quarterly_return,
                            CASE WHEN s.close_price IS NULL OR s.prev_252 IS NULL OR s.prev_252 = 0
                                 THEN NULL ELSE ROUND((s.close_price/s.prev_252 - 1)::numeric, 6) END AS yearly_return,
                            CASE WHEN s.close_price IS NULL OR f.first_close IS NULL OR f.first_close = 0
                                 THEN NULL ELSE ROUND((s.close_price/f.first_close - 1)::numeric, 6) END AS cumulative_return
                        FROM s
                        JOIN firsts f ON f.symbol = s.symbol
                        WHERE s.date = %s
                    )
                    INSERT INTO tw_stock_returns (symbol, date, daily_return, weekly_return, monthly_return, quarterly_return, yearly_return, cumulative_return)
                    SELECT symbol, date, daily_return, weekly_return, monthly_return, quarterly_return, yearly_return, cumulative_return
                    FROM t
                    ON CONFLICT (symbol, date) DO UPDATE SET
                        daily_return = EXCLUDED.daily_return,
                        weekly_return = EXCLUDED.weekly_return,
                        monthly_return = EXCLUDED.monthly_return,
                        quarterly_return = EXCLUDED.quarterly_return,
                        yearly_return = EXCLUDED.yearly_return,
                        cumulative_return = EXCLUDED.cumulative_return;
                    """,
                    (today, today, today)
                )

                conn.commit()

                # å›å ±æœ¬æ—¥ rows
                cur.execute("SELECT COUNT(*) FROM tw_stock_returns WHERE date = %s", (today,))
                today_count = cur.fetchone()[0]
                print(f"âœ… ä»Šæ—¥å ±é…¬ç‡å·²å¯«å…¥/æ›´æ–° {today_count} ç­†", flush=True)
            except Exception as e:
                print(f"âš ï¸ è¨ˆç®—/å¯«å…¥å ±é…¬ç‡å¤±æ•—: {e}", flush=True)
                conn.rollback()

            print(flush=True)
            print("=" * 80, flush=True)
            print("ğŸ‰ GitHub Actions ä»»å‹™åŸ·è¡Œå®Œæˆï¼", flush=True)
            print("=" * 80, flush=True)

        except Exception as e:
            print(f"âŒ åŸ·è¡Œéç¨‹ç™¼ç”ŸéŒ¯èª¤ï¼š{e}", flush=True)
            import traceback
            traceback.print_exc()
            sys.exit(1)

        finally:
            if cur:
                cur.close()
            if conn:
                conn.close()
        PYTHON_SCRIPT

    - name: Upload logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: fetch-logs-${{ github.run_number }}
        path: |
          *.log
        retention-days: 30

    - name: Send notification on failure
      if: failure()
      run: |
        echo "âŒ è³‡æ–™æŠ“å–å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ—¥èªŒ"
        echo "Run ID: ${{ github.run_id }}"
        echo "Run Number: ${{ github.run_number }}"
