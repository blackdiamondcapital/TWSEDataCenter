name: Fetch Historical Data Range

on:
  workflow_dispatch:
    inputs:
      start_date:
        description: 'é–‹å§‹æ—¥æœŸ (YYYY-MM-DD)'
        required: true
        default: '2025-10-01'
      end_date:
        description: 'çµæŸæ—¥æœŸ (YYYY-MM-DD)'
        required: true
        default: '2025-10-25'

env:
  TZ: Asia/Taipei

jobs:
  test-fetch:
    runs-on: ubuntu-latest
    timeout-minutes: 60  # æ”¯æ´æ—¥æœŸç¯„åœæŠ“å–ï¼Œéœ€è¦æ›´å¤šæ™‚é–“
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install psycopg2-binary requests pandas numpy beautifulsoup4 lxml
    
    - name: Fetch historical data
      env:
        NEON_DATABASE_URL: ${{ secrets.NEON_DATABASE_URL }}
        START_DATE: ${{ github.event.inputs.start_date }}
        END_DATE: ${{ github.event.inputs.end_date }}
      run: |
        python3 << 'PYTHON_SCRIPT'
        import os
        import sys
        import time
        import requests
        import psycopg2
        from psycopg2.extras import execute_values
        from datetime import datetime, date, timedelta
        from bs4 import BeautifulSoup
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import threading
        
        print("=" * 80, flush=True)
        print("ğŸ§ª æ‰¹æ¬¡æŠ“å–æ­·å²è³‡æ–™", flush=True)
        print("=" * 80, flush=True)
        
        start_date_str = os.environ.get('START_DATE')
        end_date_str = os.environ.get('END_DATE')
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
        
        print(f"ğŸ“… æ—¥æœŸç¯„åœï¼š{start_date} è‡³ {end_date}", flush=True)
        print(f"â° åŸ·è¡Œæ™‚é–“ï¼š{datetime.now()}", flush=True)
        
        # è¨ˆç®—æ—¥æœŸç¯„åœ
        date_range = []
        current = start_date
        while current <= end_date:
            date_range.append(current)
            current += timedelta(days=1)
        
        print(f"ğŸ“† å…± {len(date_range)} å¤©", flush=True)
        print(flush=True)
        
        NEON_DB_URL = os.environ.get('NEON_DATABASE_URL')
        
        if not NEON_DB_URL:
            print("âŒ éŒ¯èª¤ï¼šæœªè¨­å®š NEON_DATABASE_URL")
            sys.exit(1)
        
        try:
            conn = psycopg2.connect(NEON_DB_URL)
            cur = conn.cursor()
            print("âœ… å·²é€£æ¥åˆ° Neon è³‡æ–™åº«", flush=True)
            print(flush=True)
        except Exception as e:
            print(f"âŒ è³‡æ–™åº«é€£ç·šå¤±æ•—ï¼š{e}")
            sys.exit(1)
        
        # å–å¾—è‚¡ç¥¨æ¸…å–®
        def get_stock_symbols():
            """å–å¾—ä¸Šå¸‚ä¸Šæ«ƒè‚¡ç¥¨æ¸…å–®"""
            print("ğŸ“‹ å–å¾—è‚¡ç¥¨æ¸…å–®...", flush=True)
            headers = {'User-Agent': 'Mozilla/5.0'}
            
            # å–å¾—ä¸Šå¸‚è‚¡ç¥¨
            twse_symbols = []
            try:
                url = 'https://isin.twse.com.tw/isin/C_public.jsp?strMode=2'
                response = requests.get(url, headers=headers, timeout=30)
                response.encoding = 'big5'
                soup = BeautifulSoup(response.text, 'html.parser')
                
                for row in soup.find_all('tr'):
                    cols = row.find_all('td')
                    if len(cols) >= 5:
                        code_name = cols[0].text.strip()
                        if '\u3000' in code_name:
                            parts = code_name.split('\u3000')
                            if len(parts) == 2 and parts[0].isdigit() and len(parts[0]) == 4:
                                twse_symbols.append(parts[0])
                print(f"âœ… ä¸Šå¸‚è‚¡ç¥¨ï¼š{len(twse_symbols)} æª”", flush=True)
            except Exception as e:
                print(f"âš ï¸  ç„¡æ³•å–å¾—ä¸Šå¸‚æ¸…å–®: {e}")
            
            # å–å¾—ä¸Šæ«ƒè‚¡ç¥¨  
            tpex_symbols = []
            try:
                url = 'https://isin.twse.com.tw/isin/C_public.jsp?strMode=4'
                response = requests.get(url, headers=headers, timeout=30)
                response.encoding = 'big5'
                soup = BeautifulSoup(response.text, 'html.parser')
                
                for row in soup.find_all('tr'):
                    cols = row.find_all('td')
                    if len(cols) >= 5:
                        code_name = cols[0].text.strip()
                        security_type = cols[1].text.strip() if len(cols) > 1 else ''
                        
                        # åªå–è‚¡ç¥¨ï¼Œæ’é™¤ ETFã€æ¬Šè­‰ç­‰
                        if '\u3000' in code_name and 'è‚¡ç¥¨' in security_type:
                            parts = code_name.split('\u3000')
                            if len(parts) == 2 and parts[0].isdigit() and len(parts[0]) == 4:
                                tpex_symbols.append(parts[0])
                print(f"âœ… ä¸Šæ«ƒè‚¡ç¥¨ï¼š{len(tpex_symbols)} æª”", flush=True)
            except Exception as e:
                print(f"âš ï¸  ç„¡æ³•å–å¾—ä¸Šæ«ƒæ¸…å–®: {e}")
            
            return twse_symbols, tpex_symbols
        
        # æŠ“å–å–®æª”è‚¡ç¥¨åœ¨æ—¥æœŸç¯„åœå…§çš„è³‡æ–™
        def fetch_stock_range_data(symbol, target_dates):
            """æŠ“å–å–®æª”è‚¡ç¥¨åœ¨æŒ‡å®šæ—¥æœŸç¯„åœå…§çš„è³‡æ–™"""
            headers = {'User-Agent': 'Mozilla/5.0'}
            results = []
            
            # æŒ‰æœˆä»½åˆ†çµ„æ—¥æœŸ
            months_to_fetch = {}
            for d in target_dates:
                month_key = (d.year, d.month)
                if month_key not in months_to_fetch:
                    months_to_fetch[month_key] = []
                months_to_fetch[month_key].append(d)
            
            # é€æœˆæŠ“å–
            for (year, month), dates in months_to_fetch.items():
                try:
                    url = 'https://www.twse.com.tw/exchangeReport/STOCK_DAY'
                    params = {
                        'response': 'json',
                        'date': f'{year}{month:02d}01',
                        'stockNo': symbol
                    }
                    
                    response = requests.get(url, params=params, headers=headers, timeout=10)
                    if response.status_code != 200:
                        continue
                    
                    data = response.json()
                    if data.get('stat') == 'OK' and data.get('data'):
                        for row in data['data']:
                            try:
                                # è§£ææ—¥æœŸ
                                date_parts = row[0].split('/')
                                if len(date_parts) == 3:
                                    year_roc = int(date_parts[0]) + 1911
                                    month_val = int(date_parts[1])
                                    day_val = int(date_parts[2])
                                    trade_date = date(year_roc, month_val, day_val)
                                    
                                    # åªå–ç›®æ¨™æ—¥æœŸç¯„åœå…§çš„è³‡æ–™
                                    if trade_date in dates:
                                        volume = int(row[1].replace(',', '')) if row[1] != '--' else 0
                                        open_price = float(row[3].replace(',', '')) if row[3] != '--' else None
                                        high_price = float(row[4].replace(',', '')) if row[4] != '--' else None
                                        low_price = float(row[5].replace(',', '')) if row[5] != '--' else None
                                        close_price = float(row[6].replace(',', '')) if row[6] != '--' else None
                                        transaction_count = int(row[8].replace(',', '')) if len(row) > 8 and row[8] != '--' else 0
                                        
                                        if close_price and 0 < close_price < 30000:
                                            results.append((
                                                symbol, trade_date, open_price, high_price,
                                                low_price, close_price, volume, transaction_count
                                            ))
                            except (ValueError, IndexError):
                                continue
                    
                    time.sleep(0.3)
                    
                except:
                    pass
            
            return results
        
        try:
            # 1. å–å¾—è‚¡ç¥¨æ¸…å–®
            twse_symbols, tpex_symbols = get_stock_symbols()
            all_symbols = twse_symbols + tpex_symbols
            
            if not all_symbols:
                print("âŒ ç„¡æ³•å–å¾—è‚¡ç¥¨æ¸…å–®")
                sys.exit(1)
            
            print(f"\nğŸ“Š æº–å‚™æŠ“å– {len(all_symbols)} æª”è‚¡ç¥¨ï¼Œå…± {len(date_range)} å¤©", flush=True)
            print(flush=True)
            
            # 2. ä½¿ç”¨ä½µç™¼æŠ“å–
            all_records = []
            lock = threading.Lock()
            
            def fetch_and_collect(symbol):
                """ä½µç™¼æŠ“å–å–®æª”è‚¡ç¥¨"""
                results = fetch_stock_range_data(symbol, date_range)
                if results:
                    with lock:
                        all_records.extend(results)
                return len(results)
            
            print("ğŸ“¥ ä½¿ç”¨ä½µç™¼æŠ“å–ï¼ˆ10 ä½µç™¼ï¼‰...", flush=True)
            success_stocks = 0
            total_records = 0
            
            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = {executor.submit(fetch_and_collect, symbol): symbol 
                          for symbol in all_symbols}
                
                for i, future in enumerate(as_completed(futures), 1):
                    count = future.result()
                    if count > 0:
                        success_stocks += 1
                        total_records += count
                    
                    # æ¯100æª”é¡¯ç¤ºé€²åº¦
                    if i % 100 == 0:
                        print(f"  é€²åº¦: {i}/{len(all_symbols)}, æˆåŠŸ: {success_stocks} æª”, è³‡æ–™: {total_records} ç­†", flush=True)
            
            print(f"\nâœ… å®Œæˆï¼š{success_stocks} / {len(all_symbols)} æª”", flush=True)
            print(f"ğŸ“¦ ç¸½è¨ˆæŠ“å–ï¼š{len(all_records)} ç­†è³‡æ–™", flush=True)
            
            if not all_records:
                print("âš ï¸  ç„¡è³‡æ–™å¯åŒæ­¥ï¼ˆå¯èƒ½æ˜¯éäº¤æ˜“æ—¥ï¼‰")
                print("âœ… æ¸¬è©¦å®Œæˆï¼ˆç„¡è³‡æ–™æ›´æ–°ï¼‰")
                sys.exit(0)
            
            print()
            print(f"ğŸ“¦ æº–å‚™åŒæ­¥ {len(all_records)} ç­†è³‡æ–™åˆ° Neon è³‡æ–™åº«...")
            
            execute_values(
                cur,
                """
                INSERT INTO stock_prices 
                (symbol, date, open_price, high_price, low_price, 
                 close_price, volume, transaction_count)
                VALUES %s
                ON CONFLICT (symbol, date) 
                DO UPDATE SET
                    open_price = EXCLUDED.open_price,
                    high_price = EXCLUDED.high_price,
                    low_price = EXCLUDED.low_price,
                    close_price = EXCLUDED.close_price,
                    volume = EXCLUDED.volume,
                    transaction_count = EXCLUDED.transaction_count
                """,
                all_records
            )
            
            conn.commit()
            
            print(f"âœ… æˆåŠŸåŒæ­¥ {len(all_records)} ç­†è³‡æ–™åˆ° Neon")
            print()
            print("=" * 80)
            print("ğŸ‰ æ¸¬è©¦å®Œæˆï¼")
            print("=" * 80)
            
        except Exception as e:
            print(f"âŒ åŸ·è¡Œéç¨‹ç™¼ç”ŸéŒ¯èª¤ï¼š{e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
            
        finally:
            if cur:
                cur.close()
            if conn:
                conn.close()
        PYTHON_SCRIPT
